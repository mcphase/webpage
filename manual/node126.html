<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2017.2 (Released Jan 23, 2017) -->
<HTML>
<HEAD>
<TITLE>Module brillouin - an Isotropic Spin Single Ion Module</TITLE>
<META NAME="description" CONTENT="Module brillouin - an Isotropic Spin Single Ion Module">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2017.2">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="node127.html">
<LINK REL="previous" HREF="node125.html">
<LINK REL="up" HREF="manual.html">
<LINK REL="next" HREF="node127.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html2184"
  HREF="node127.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2178"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2172"
  HREF="node125.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2180"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2182"
  HREF="node152.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2185"
  HREF="node127.html">DyNiBC - single ion</A>
<B> Up:</B> <A NAME="tex2html2179"
  HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A NAME="tex2html2173"
  HREF="node125.html">Module kramer - a</A>
 &nbsp; <B>  <A NAME="tex2html2181"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html2183"
  HREF="node152.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION000260000000000000000"></A><A NAME="brillouin"></A>
<BR>
Module <I CLASS="slanted">brillouin</I> - an Isotropic Spin Single Ion Module
</H1>

<P>
A magnetic ion often can be described by a pure spin moment (transition
metal ions, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$^{3+}$"></SPAN>Gd, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1062.png"
 ALT="$^{2+}$"></SPAN>Eu). In this description the magnetic moment
<!-- MATH
 ${\mathbf M}=g_J \mu_B <{\hat \mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="137" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img1063.png"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\hat \mathbf J}&gt;_T$"></SPAN> is calculated by the Brillouin function. 

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\hat \mathbf J>=\frac{\mathbf H}{|\mathbf H|} B_{J}(x=g_J \mu_B |\mathbf H|/kT)
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="237" HEIGHT="44" BORDER="0"
 SRC="img1064.png"
 ALT="\begin{displaymath}
&lt;\hat \mathbf J&gt;=\frac{\mathbf H}{\vert\mathbf H\vert} B_{J}(x=g_J \mu_B \vert\mathbf H\vert/kT)
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">149</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
with

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
B_J(x)=\frac{\sum_{m=-J}^{J} m x^m}{\sum_{m=-J}^{J}  x^m}=
\frac{J(x^{J+2}-x^{-J})+(J+1)x(x^{-J}-x^J)}{(1-x)(x^{-J}-x^{J+1})}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="446" HEIGHT="55" BORDER="0"
 SRC="img1065.png"
 ALT="\begin{displaymath}
B_J(x)=\frac{\sum_{m=-J}^{J} m x^m}{\sum_{m=-J}^{J} x^m}=
...
...{J(x^{J+2}-x^{-J})+(J+1)x(x^{-J}-x^J)}{(1-x)(x^{-J}-x^{J+1})}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">150</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Note that the partition sum <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1066.png"
 ALT="$Z$"></SPAN> is given by <!-- MATH
 $Z=\sum_{m=-J}^{J}  x^m=\frac{x^{J+1}-x^{-J}}{x-1}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="205" HEIGHT="43" ALIGN="MIDDLE" BORDER="0"
 SRC="img1067.png"
 ALT="$Z=\sum_{m=-J}^{J} x^m=\frac{x^{J+1}-x^{-J}}{x-1}$"></SPAN>.
This is all what is needed to calculate the mean field ground state with 
module <I CLASS="slanted">mcphas</I>.

<P>
For the calculation of the dynamical properties using module <I CLASS="slanted">mcdisp<A NAME="12717"></A></I>
the single ion susceptibility of for a free magnetic ion is needed. In principle
there are (J-1) transitions with non vanishing matrix elements of
the momentum operator <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1060.png"
 ALT="$\mathbf J$"></SPAN> with all having the same
 excitation energy <!-- MATH
 $\Delta=g_J \mu_B H$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1068.png"
 ALT="$\Delta=g_J \mu_B H$"></SPAN>.
 These different transitions can
be combined into one effective inelastic excitation. The corresponding
transition matrix to be used in equation&nbsp;(<A HREF="node140.html#mmatrix">230</A>) of the MF-RPA formalism
is given by 

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
M_{\alpha\beta}=\frac{-b_{\alpha}b_{\beta}R_J}{Z}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="120" HEIGHT="39" BORDER="0"
 SRC="img1069.png"
 ALT="\begin{displaymath}
M_{\alpha\beta}=\frac{-b_{\alpha}b_{\beta}R_J}{Z}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">151</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
with the angular dependence given by the vector <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img241.png"
 ALT="$\mathbf b$"></SPAN>

<P>
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
b_x& = & \frac{-H_y+i H_x \frac{H_z}{|\mathbf H|}}{2|\mathbf H| sin\Theta} \\
b_y& = & \frac{H_x+i H_y \frac{H_z}{|\mathbf H|}}{2|\mathbf H| sin\Theta} \\
b_z& = & \frac{H_x^2+H_y^2}{2i|\mathbf H|^2 sin\Theta}=\frac{-isin\Theta}{2} \\
&&sin\Theta=\frac{\sqrt{H_x^2+H_y^2}}{|\mathbf H|}
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1070.png"
 ALT="$\displaystyle b_x$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="110" HEIGHT="66" ALIGN="MIDDLE" BORDER="0"
 SRC="img1071.png"
 ALT="$\displaystyle \frac{-H_y+i H_x \frac{H_z}{\vert\mathbf H\vert}}{2\vert\mathbf H\vert sin\Theta}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">152</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="18" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1072.png"
 ALT="$\displaystyle b_y$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="97" HEIGHT="66" ALIGN="MIDDLE" BORDER="0"
 SRC="img1073.png"
 ALT="$\displaystyle \frac{H_x+i H_y \frac{H_z}{\vert\mathbf H\vert}}{2\vert\mathbf H\vert sin\Theta}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">153</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="18" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1074.png"
 ALT="$\displaystyle b_z$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="164" HEIGHT="58" ALIGN="MIDDLE" BORDER="0"
 SRC="img1075.png"
 ALT="$\displaystyle \frac{H_x^2+H_y^2}{2i\vert\mathbf H\vert^2 sin\Theta}=\frac{-isin\Theta}{2}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">154</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="142" HEIGHT="79" ALIGN="MIDDLE" BORDER="0"
 SRC="img1076.png"
 ALT="$\displaystyle sin\Theta=\frac{\sqrt{H_x^2+H_y^2}}{\vert\mathbf H\vert}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">155</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
and with the sum <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1077.png"
 ALT="$R_J$"></SPAN> given by

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
R_J=(x-1)\sum_{m=-J}^{J-1}(J+m+1)(J-m)x^m=\frac{2Jx^{-J}+(2J+2)x(x^{J}-x^{-J})-2Jx^{J+2}}{(1-x)^2}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="572" HEIGHT="58" BORDER="0"
 SRC="img1078.png"
 ALT="\begin{displaymath}
R_J=(x-1)\sum_{m=-J}^{J-1}(J+m+1)(J-m)x^m=\frac{2Jx^{-J}+(2J+2)x(x^{J}-x^{-J})-2Jx^{J+2}}{(1-x)^2}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">156</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
The module given in <I CLASS="slanted">/examples/gdni2b2c/1ion_mod/brillouin.c</I> 
can be compiled
by typing make in the directory <I CLASS="slanted">/examples/gdni2b2c/1ion_mod/</I> thus using the
<I CLASS="slanted">/examples/gdni2b2c/1ion_mod/makefile</I>. It 
evaluates the Brillouin function and thus calculates the thermal expectation 
value <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img1059.png"
 ALT="$&lt;&gt;_T$"></SPAN> of the vector <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1060.png"
 ALT="$\mathbf J$"></SPAN>. 
The moment <!-- MATH
 ${\mathbf M}=g_J \mu_B <{\mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="137" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1061.png"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\mathbf J}&gt;_T$"></SPAN>
is returned to the mcphas<A NAME="12753"></A> program:

<P>
//<PRE>

// module brillouin.c
// example c file for dynamically loadable module of program
// mcphas ... this must not contain c++ code, but pure c code 
// which is being compiled with gcc and linked 
// with ld  !! 

#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;vector.h&gt;

#define MU_B 0.05788
#define K_B  0.0862
#define SMALL 1e-10


// this is called directly after loading it into memory from dlopen
void _init(void)
{  fprintf(stdout,"brillouin.so: is loaded\n");}

// called just before removing from memory
void _fini(void)
{  fprintf(stdout,"brillouin.so: is removed\n");}

//routine Icalc for brillouin 
#ifdef __MINGW32__
extern "C" __declspec(dllexport) void Icalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#else
extern "C" void Icalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#endif
{   
    /*on input
    T		temperature[K]
    gJmbH	vector of effective field [meV]
    gJ          Lande factor
    ABC         ABC(1) ... spin quantum number S=J
  on output    
    J		single ion momentum vector &lt;J&gt;
    Z		single ion partition function
    U		single ion magnetic energy
*/
Vector gjmbH(1,gjmbHxc.Hi());
gjmbH=gjmbHxc+(*g_J)*MU_B*Hext;
// check dimensions of vector
if(J.Hi()!=3||gjmbH.Hi()!=3||ABC.Hi()!=1)
   {fprintf(stderr,"Error loadable module brillouin.so: wrong number of dimensions - check number of columns in file mcphas.j or number of parameters in single ion property file\n");
    exit(EXIT_FAILURE);}
    
double JJ,K_BT,XJ,gmhkt,Jav,gmh,Z,X;

// program brillouin function for S=J=ABC(1)
JJ=ABC[1];
K_BT=(*T)*K_B;
gmh=Norm(gjmbH);
gmhkt=gmh/K_BT;
if(JJ*gmhkt&gt;100||gmhkt&gt;100){Jav=JJ;(*lnZ)=JJ*gmhkt;}
 else
 {X=exp(gmhkt);
  XJ=exp(JJ*gmhkt);

//printf("1-X=%g gmh=%g",1-X,gmh);

// calculate Brillouin function and partition sum Z
if (X&lt;=1.000001){Z=2*JJ+1;Jav=0;}
else
{Z=(XJ*X-1/XJ)/(X-1.0);
 Jav=JJ*(XJ*X*X-1/XJ)+(JJ+1)*X*(1.0/XJ-XJ);
 Jav/=(X-1);
 Jav/=(XJ*X-1/XJ);
}
// the above formula is equivalent to the following summing routine:
//for (i=-JJ*2;i&lt;=+0.000001;++i)
//{dd=i*gmhkt;
// if (dd&lt;-700){expp=0;}else{expp=exp(dd);}
// Z += expp; //this is not yet Z, a factor exp(J gJ Heff/kT) is missing
//}
//Jav=0;
//for (i=-JJ*2;i&lt;=+0.000001;++i)
//{dd=i*gmhkt;
// if (dd&lt;-700){expp=0;}else{expp=exp(dd);}
// Jav+=(JJ+i)*expp/Z;
//}
//Z*=exp(JJ*gmhkt); //this is now the correct Z

// calculate magnetic energy U
(*lnZ)=log(Z);
}
(*U)=-gmh*Jav;



if (gmh&gt;0)
{  J[1] = Jav*gjmbH(1)/gmh;
  J[2] = Jav*gjmbH(2)/gmh;
  J[3] = Jav*gjmbH(3)/gmh;
 }
 else
 {J=0;}
//  printf ("Ha=%g Hb=%g Hc=%g ma=%g mb=%g mc=%g \n", H[1], H[2], H[3], m[1], m[2], m[3]);
return;
}

#ifdef __MINGW32__
extern "C" __declspec(dllexport) void mcalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      ComplexMatrix &amp; est)
#else
extern "C" void mcalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      ComplexMatrix &amp; est)
#endif
{double lnZ,U;
 Icalc(J,T,gjmbHxc,Hext,g_J,ABC,sipffile,&amp;lnZ,&amp;U,est);
 double GJ=2.0;
 J*=GJ;
}
/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32
extern "C" __declspec(dllexport) int du1calc(int &amp; tn,double &amp; T,Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J,Vector &amp; ABC, char ** sipffile,
                       ComplexVector &amp; u1,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#else
extern "C" int du1calc(int &amp; tn,double &amp; T,Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J,Vector &amp; ABC, char ** sipffile,
                       ComplexVector &amp; u1,float &amp; delta,int &amp; n , int &amp; nd, ComplexMatrix &amp; est)
#endif
{ 
  /*on input
    tn          transition-number
    ABC         A,M,Ci...saturation moment/gJ[MU_B] of groundstate doublet in a.b.c direction
    g_J		lande factor
    T		temperature[K]
    gjmbH	vector of effective field [meV]
  on output    
    delta	splittings [meV] 
    u1(i)	transition vector elements ...
*/
static Vector J(1,3);
int pr;
Vector gjmbH(1,gjmbHxc.Hi());
gjmbH=gjmbHxc+(*g_J)*MU_B*Hext;
// clalculate thermal expectation values (needed for quasielastic scattering)
//  Icalc(J,&amp;T,gjmbH,g_J,ABC,&amp;lnz,&amp;u);
  pr=1;
  if (tn&lt;0) {pr=0;tn*=-1;}
  if (T&lt;0){T=-T;}
  double JJ,K_BT,XJ,gmhkt,gmh,Z,R,X,sinth,hxxyy,jjkt,corr;
  complex &lt;double&gt; i(0,1),bx,by,bz;

// program brillouin function for S=J=ABC(1)
  JJ=ABC[1];
  K_BT=T*K_B;
  gmh=Norm(gjmbH);
  gmhkt=gmh/K_BT;
  X=exp(gmhkt);
  XJ=exp(JJ*gmhkt);
// calculate Z and R
if (X==1.0){Z=2*JJ+1;R=0;}
else
{if(X&gt;1e50){Z=XJ;R=-2.0*JJ*XJ;}
 else
 {Z=(XJ*X-1/XJ)/(X-1.0);
  R=JJ*(1/XJ-XJ*X*X)+(JJ+1)*X*(XJ-1.0/XJ);
  R/=0.5*(X-1)*(X-1);
 }
}

// calculate coefficients bx,by,bz
 hxxyy=gjmbH(1)*gjmbH(1)+gjmbH(2)*gjmbH(2);
 if (hxxyy/gjmbH(3)/gjmbH(3)&gt;SMALL*SMALL)
 {sinth=sqrt(hxxyy)/gmh;
  bx=-gjmbH(2)+i*gjmbH(1)*gjmbH(3)/gmh;
  bx/=2*gmh*sinth;
  by=gjmbH(1)+i*gjmbH(2)*gjmbH(3)/gmh;
  by/=2*gmh*sinth;
  }
 else
 {sinth=0;by=0.5;
  if(gjmbH(3)&gt;0)
  {bx=0.5*i;}
  else
  {bx=-0.5*i;}
 }
  bz=-i*sinth*0.5;
// -----------------------------------------

if (tn==2) // transition to finite energy
 {delta=gmh; //set delta !!!

 if (delta&gt;SMALL)
  {// now lets calculate mat
  u1(1)=bx*sqrt(-R/Z);
  u1(2)=by*sqrt(-R/Z);
  u1(3)=bz*sqrt(-R/Z);
  } else
  {// quasielastic scattering needs epsilon * nm / KT ....
  jjkt=0.6666667*JJ*(JJ+1)/K_BT;
  u1(1)=bx*sqrt(jjkt);
  u1(2)=by*sqrt(jjkt);
  u1(3)=bz*sqrt(jjkt);
  }
 }
 else
 { delta=-SMALL; // tn=1 ... transition within the same level
   if(X==1.0){jjkt=JJ*(2*JJ*JJ+3*JJ+1)/3/K_BT/(2*JJ+1);}
   else {if(X&gt;1e50)
         {jjkt=-JJ*JJ*K_BT;}
         else 
         {jjkt=(1-2*JJ-2*JJ*JJ)/XJ;
         jjkt+=JJ*JJ/X/XJ;
	 jjkt+=(JJ*JJ+2*JJ+1)*X/XJ;
	 jjkt-=(JJ+1)*(JJ+1)*XJ;
	 jjkt+=(2*JJ*JJ+2*JJ-1)*XJ*X;
	 jjkt-=JJ*JJ*XJ*X*X;
	 jjkt*=X/(1-X)/(1-X);
	 jjkt/=(1/XJ-X*XJ)*K_BT;
         jjkt/=(1/XJ-X*XJ);
         corr=JJ*(XJ*X*X-1/XJ)+(JJ+1)*X*(1/XJ-XJ);
         corr/=(1-X)*(1/XJ-X*XJ);
         jjkt-=corr*corr;
         jjkt/=K_BT;
         }
        }
 // now lets calculate mat
 u1(1)=gjmbH(1)*sqrt(jjkt)/gmh;
 u1(2)=gjmbH(2)*sqrt(jjkt)/gmh;
 u1(3)=gjmbH(3)*sqrt(jjkt)/gmh;
 }
if (pr==1) printf ("delta=%4.6g meV\n",delta);

// brillouin function has 2 effective transitions
return 2;
}
//
</PRE>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html2184"
  HREF="node127.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2178"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2172"
  HREF="node125.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2180"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2182"
  HREF="node152.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2185"
  HREF="node127.html">DyNiBC - single ion</A>
<B> Up:</B> <A NAME="tex2html2179"
  HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A NAME="tex2html2173"
  HREF="node125.html">Module kramer - a</A>
 &nbsp; <B>  <A NAME="tex2html2181"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html2183"
  HREF="node152.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
