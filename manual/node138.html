<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2024.2 (Released October 21, 2024) -->
<HTML lang="en">
<HEAD>
<TITLE>Module brillouin - an Isotropic Spin Single Ion Module</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2024.2">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="node139.html">
<LINK REL="previous" HREF="node137.html">
<LINK REL="next" HREF="node139.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node139.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node137.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1052"
  HREF="node7.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1054"
  HREF="node164.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node139.html">DyNiBC - single ion</A>
<B> Up:</B> <A
 HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A
 HREF="node137.html">Module kramer - a</A>
 &nbsp; <B>  <A ID="tex2html1053"
  HREF="node7.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1055"
  HREF="node164.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION000260000000000000000"></A><A ID="brillouin"></A>
<BR>
Module <I CLASS="slanted">brillouin</I> - an Isotropic Spin Single Ion Module
</H1>

<P>
A magnetic ion often can be described by a pure spin moment (transition
metal ions, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.12ex; " SRC="img3.svg"
 ALT="$^{3+}$"></SPAN>Gd, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.12ex; " SRC="img1158.svg"
 ALT="$^{2+}$"></SPAN>Eu). In this description the magnetic moment
<!-- MATH
 ${\mathbf M}=g_J \mu_B <{\hat \mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.88ex; vertical-align: -0.57ex; " SRC="img1159.svg"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\hat \mathbf J}&gt;_T$"></SPAN> is calculated by the Brillouin function. 

<P>

<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\hat \mathbf J>=\frac{\mathbf H}{|\mathbf H|} B_{J}(x=g_J \mu_B |\mathbf H|/kT)
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 5.55ex; vertical-align: -2.29ex; " SRC="img1160.svg"
 ALT="$\displaystyle &lt;\hat \mathbf J&gt;=\frac{\mathbf H}{\vert\mathbf H\vert} B_{J}(x=g_J \mu_B \vert\mathbf H\vert/kT)
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">156</SPAN>)</SPAN>
</DIV>

<P>
with

<P>

<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
B_J(x)=\frac{\sum_{m=-J}^{J} m x^m}{\sum_{m=-J}^{J}  x^m}=
\frac{J(x^{J+2}-x^{-J})+(J+1)x(x^{-J}-x^J)}{(1-x)(x^{-J}-x^{J+1})}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 7.19ex; vertical-align: -3.03ex; " SRC="img1161.svg"
 ALT="$\displaystyle B_J(x)=\frac{\sum_{m=-J}^{J} m x^m}{\sum_{m=-J}^{J} x^m}=
\frac{J(x^{J+2}-x^{-J})+(J+1)x(x^{-J}-x^J)}{(1-x)(x^{-J}-x^{J+1})}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">157</SPAN>)</SPAN>
</DIV>

<P>
Note that the partition sum <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.81ex; vertical-align: -0.12ex; " SRC="img1162.svg"
 ALT="$Z$"></SPAN> is given by <!-- MATH
 $Z=\sum_{m=-J}^{J}  x^m=\frac{x^{J+1}-x^{-J}}{x-1}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.62ex; vertical-align: -1.11ex; " SRC="img1163.svg"
 ALT="$Z=\sum_{m=-J}^{J} x^m=\frac{x^{J+1}-x^{-J}}{x-1}$"></SPAN>.
This is all what is needed to calculate the mean field ground state with 
module <I CLASS="slanted">mcphas</I>.

<P>
For the calculation of the dynamical properties using module <I CLASS="slanted">mcdisp<A ID="5383"></A></I>
the single ion susceptibility of for a free magnetic ion is needed. In principle
there are (J-1) transitions with non vanishing matrix elements of
the momentum operator <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.82ex; vertical-align: -0.12ex; " SRC="img1156.svg"
 ALT="$\mathbf J$"></SPAN> with all having the same
 excitation energy <!-- MATH
 $\Delta=g_J \mu_B H$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.26ex; vertical-align: -0.57ex; " SRC="img1164.svg"
 ALT="$\Delta=g_J \mu_B H$"></SPAN>.
 These different transitions can
be combined into one effective inelastic excitation. The corresponding
transition matrix to be used in equation&nbsp;(<A HREF="node152.html#mmatrix">240</A>) of the MF-RPA formalism
is given by 

<P>

<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
M_{\alpha\beta}=\frac{-b_{\alpha}b_{\beta}R_J}{Z}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 4.99ex; vertical-align: -1.71ex; " SRC="img1165.svg"
 ALT="$\displaystyle M_{\alpha\beta}=\frac{-b_{\alpha}b_{\beta}R_J}{Z}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">158</SPAN>)</SPAN>
</DIV>

<P>
with the angular dependence given by the vector <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.12ex; " SRC="img1166.svg"
 ALT="$\mathbf b$"></SPAN>

<P>
<BR>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{eqnarray}
b_x& = & \frac{-H_y+i H_x \frac{H_z}{|\mathbf H|}}{2|\mathbf H| sin\Theta} \\
b_y& = & \frac{H_x+i H_y \frac{H_z}{|\mathbf H|}}{2|\mathbf H| sin\Theta} \\
b_z& = & \frac{H_x^2+H_y^2}{2i|\mathbf H|^2 sin\Theta}=\frac{-isin\Theta}{2} \\
&&sin\Theta=\frac{\sqrt{H_x^2+H_y^2}}{|\mathbf H|}
\end{eqnarray}
 -->
<TABLE CLASS="equation" >
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.46ex; " SRC="img1167.svg"
 ALT="$\displaystyle b_x$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 1.08ex; vertical-align: -0.12ex; " SRC="img94.svg"
 ALT="$\textstyle =$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 6.56ex; vertical-align: -2.29ex; " SRC="img1168.svg"
 ALT="$\displaystyle \frac{-H_y+i H_x \frac{H_z}{\vert\mathbf H\vert}}{2\vert\mathbf H\vert sin\Theta}$"></TD><TD class="rfill">(<SPAN CLASS="arabic">159</SPAN>)</TD></TR>
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 2.50ex; vertical-align: -0.78ex; " SRC="img1169.svg"
 ALT="$\displaystyle b_y$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 1.08ex; vertical-align: -0.12ex; " SRC="img94.svg"
 ALT="$\textstyle =$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 6.56ex; vertical-align: -2.29ex; " SRC="img1170.svg"
 ALT="$\displaystyle \frac{H_x+i H_y \frac{H_z}{\vert\mathbf H\vert}}{2\vert\mathbf H\vert sin\Theta}$"></TD><TD class="rfill">(<SPAN CLASS="arabic">160</SPAN>)</TD></TR>
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.46ex; " SRC="img1171.svg"
 ALT="$\displaystyle b_z$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 1.08ex; vertical-align: -0.12ex; " SRC="img94.svg"
 ALT="$\textstyle =$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 6.07ex; vertical-align: -2.29ex; " SRC="img1172.svg"
 ALT="$\displaystyle \frac{H_x^2+H_y^2}{2i\vert\mathbf H\vert^2 sin\Theta}=\frac{-isin\Theta}{2}$"></TD><TD class="rfill">(<SPAN CLASS="arabic">161</SPAN>)</TD></TR>
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 7.56ex; vertical-align: -2.29ex; " SRC="img1173.svg"
 ALT="$\displaystyle sin\Theta=\frac{\sqrt{H_x^2+H_y^2}}{\vert\mathbf H\vert}$"></TD><TD class="rfill">(<SPAN CLASS="arabic">162</SPAN>)</TD></TR>
</TABLE></DIV>

<P>
and with the sum <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.46ex; " SRC="img1174.svg"
 ALT="$R_J$"></SPAN> given by

<P>

<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
R_J=(x-1)\sum_{m=-J}^{J-1}(J+m+1)(J-m)x^m=\frac{2Jx^{-J}+(2J+2)x(x^{J}-x^{-J})-2Jx^{J+2}}{(1-x)^2}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 7.65ex; vertical-align: -3.32ex; " SRC="img1175.svg"
 ALT="$\displaystyle R_J=(x-1)\sum_{m=-J}^{J-1}(J+m+1)(J-m)x^m=\frac{2Jx^{-J}+(2J+2)x(x^{J}-x^{-J})-2Jx^{J+2}}{(1-x)^2}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">163</SPAN>)</SPAN>
</DIV>

<P>
The module given in <I CLASS="slanted">/examples/gdni2b2c/1ion_mod/brillouin.c</I> 
can be compiled
by typing make in the directory <I CLASS="slanted">/examples/gdni2b2c/1ion_mod/</I> thus using the
<I CLASS="slanted">/examples/gdni2b2c/1ion_mod/makefile</I>. It 
evaluates the Brillouin function and thus calculates the thermal expectation 
value <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.83ex; vertical-align: -0.46ex; " SRC="img1155.svg"
 ALT="$&lt;&gt;_T$"></SPAN> of the vector <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.82ex; vertical-align: -0.12ex; " SRC="img1156.svg"
 ALT="$\mathbf J$"></SPAN>. 
The moment <!-- MATH
 ${\mathbf M}=g_J \mu_B <{\mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.57ex; " SRC="img1157.svg"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\mathbf J}&gt;_T$"></SPAN>
is returned to the mcphas<A ID="5419"></A> program:

<P>
//<SPAN CLASS="FOOTNOTESIZE"></SPAN><PRE>

// module brillouin.c
// example c file for dynamically loadable module of program
// mcphas ... this must not contain c++ code, but pure c code 
// which is being compiled with gcc and linked 
// with ld  !! 

#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;vector.h&gt;

#define MU_B 0.05788
#define K_B  0.0862
#define SMALL 1e-10


// this is called directly after loading it into memory from dlopen
void _init(void)
{  fprintf(stdout,"brillouin.so: is loaded\n");}

// called just before removing from memory
void _fini(void)
{  fprintf(stdout,"brillouin.so: is removed\n");}

//routine Icalc for brillouin 
#ifdef __MINGW32__
extern "C" __declspec(dllexport) void Icalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#else
extern "C" void Icalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#endif
{   
    /*on input
    T		temperature[K]
    gJmbH	vector of effective field [meV]
    gJ          Lande factor
    ABC         ABC(1) ... spin quantum number S=J
  on output    
    J		single ion momentum vector &lt;J&gt;
    Z		single ion partition function
    U		single ion magnetic energy
*/
Vector gjmbH(1,gjmbHxc.Hi());
gjmbH=gjmbHxc+(*g_J)*MU_B*Hext;
// check dimensions of vector
if(J.Hi()!=3||gjmbH.Hi()!=3||ABC.Hi()!=1)
   {fprintf(stderr,"Error loadable module brillouin.so: wrong number of dimensions - check number of columns in file mcphas.j or number of parameters in single ion property file\n");
    exit(EXIT_FAILURE);}
    
double JJ,K_BT,XJ,gmhkt,Jav,gmh,Z,X;

// program brillouin function for S=J=ABC(1)
JJ=ABC[1];
K_BT=(*T)*K_B;
gmh=Norm(gjmbH);
gmhkt=gmh/K_BT;
if(JJ*gmhkt&gt;100||gmhkt&gt;100){Jav=JJ;(*lnZ)=JJ*gmhkt;}
 else
 {X=exp(gmhkt);
  XJ=exp(JJ*gmhkt);

//printf("1-X=%g gmh=%g",1-X,gmh);

// calculate Brillouin function and partition sum Z
if (X&lt;=1.000001){Z=2*JJ+1;Jav=0;}
else
{Z=(XJ*X-1/XJ)/(X-1.0);
 Jav=JJ*(XJ*X*X-1/XJ)+(JJ+1)*X*(1.0/XJ-XJ);
 Jav/=(X-1);
 Jav/=(XJ*X-1/XJ);
}
// the above formula is equivalent to the following summing routine:
//for (i=-JJ*2;i&lt;=+0.000001;++i)
//{dd=i*gmhkt;
// if (dd&lt;-700){expp=0;}else{expp=exp(dd);}
// Z += expp; //this is not yet Z, a factor exp(J gJ Heff/kT) is missing
//}
//Jav=0;
//for (i=-JJ*2;i&lt;=+0.000001;++i)
//{dd=i*gmhkt;
// if (dd&lt;-700){expp=0;}else{expp=exp(dd);}
// Jav+=(JJ+i)*expp/Z;
//}
//Z*=exp(JJ*gmhkt); //this is now the correct Z

// calculate magnetic energy U
(*lnZ)=log(Z);
}
(*U)=-gmh*Jav;



if (gmh&gt;0)
{  J[1] = Jav*gjmbH(1)/gmh;
  J[2] = Jav*gjmbH(2)/gmh;
  J[3] = Jav*gjmbH(3)/gmh;
 }
 else
 {J=0;}
//  printf ("Ha=%g Hb=%g Hc=%g ma=%g mb=%g mc=%g \n", H[1], H[2], H[3], m[1], m[2], m[3]);
return;
}

#ifdef __MINGW32__
extern "C" __declspec(dllexport) void mcalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      ComplexMatrix &amp; est)
#else
extern "C" void mcalc(Vector &amp; J,double * T, Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J, Vector &amp; ABC,char ** sipffile,
                      ComplexMatrix &amp; est)
#endif
{double lnZ,U;
 Icalc(J,T,gjmbHxc,Hext,g_J,ABC,sipffile,&amp;lnZ,&amp;U,est);
 double GJ=2.0;
 J*=GJ;
}
/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32
extern "C" __declspec(dllexport) int du1calc(int &amp; tn,double &amp; T,Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J,Vector &amp; ABC, char ** sipffile,
                       ComplexVector &amp; u1,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#else
extern "C" int du1calc(int &amp; tn,double &amp; T,Vector &amp; gjmbHxc,Vector &amp; Hext,double * g_J,Vector &amp; ABC, char ** sipffile,
                       ComplexVector &amp; u1,float &amp; delta,int &amp; n , int &amp; nd, ComplexMatrix &amp; est)
#endif
{ 
  /*on input
    tn          transition-number
    ABC         A,M,Ci...saturation moment/gJ[MU_B] of groundstate doublet in a.b.c direction
    g_J		lande factor
    T		temperature[K]
    gjmbH	vector of effective field [meV]
  on output    
    delta	splittings [meV] 
    u1(i)	transition vector elements ...
*/
static Vector J(1,3);
int pr;
Vector gjmbH(1,gjmbHxc.Hi());
gjmbH=gjmbHxc+(*g_J)*MU_B*Hext;
// clalculate thermal expectation values (needed for quasielastic scattering)
//  Icalc(J,&amp;T,gjmbH,g_J,ABC,&amp;lnz,&amp;u);
  pr=1;
  if (tn&lt;0) {pr=0;tn*=-1;}
  if (T&lt;0){T=-T;}
  double JJ,K_BT,XJ,gmhkt,gmh,Z,R,X,sinth,hxxyy,jjkt,corr;
  complex &lt;double&gt; i(0,1),bx,by,bz;

// program brillouin function for S=J=ABC(1)
  JJ=ABC[1];
  K_BT=T*K_B;
  gmh=Norm(gjmbH);
  gmhkt=gmh/K_BT;
  X=exp(gmhkt);
  XJ=exp(JJ*gmhkt);
// calculate Z and R
if (X==1.0){Z=2*JJ+1;R=0;}
else
{if(X&gt;1e50){Z=XJ;R=-2.0*JJ*XJ;}
 else
 {Z=(XJ*X-1/XJ)/(X-1.0);
  R=JJ*(1/XJ-XJ*X*X)+(JJ+1)*X*(XJ-1.0/XJ);
  R/=0.5*(X-1)*(X-1);
 }
}

// calculate coefficients bx,by,bz
 hxxyy=gjmbH(1)*gjmbH(1)+gjmbH(2)*gjmbH(2);
 if (hxxyy/gjmbH(3)/gjmbH(3)&gt;SMALL*SMALL)
 {sinth=sqrt(hxxyy)/gmh;
  bx=-gjmbH(2)+i*gjmbH(1)*gjmbH(3)/gmh;
  bx/=2*gmh*sinth;
  by=gjmbH(1)+i*gjmbH(2)*gjmbH(3)/gmh;
  by/=2*gmh*sinth;
  }
 else
 {sinth=0;by=0.5;
  if(gjmbH(3)&gt;0)
  {bx=0.5*i;}
  else
  {bx=-0.5*i;}
 }
  bz=-i*sinth*0.5;
// -----------------------------------------

if (tn==2) // transition to finite energy
 {delta=gmh; //set delta !!!

 if (delta&gt;SMALL)
  {// now lets calculate mat
  u1(1)=bx*sqrt(-R/Z);
  u1(2)=by*sqrt(-R/Z);
  u1(3)=bz*sqrt(-R/Z);
  } else
  {// quasielastic scattering needs epsilon * nm / KT ....
  jjkt=0.6666667*JJ*(JJ+1)/K_BT;
  u1(1)=bx*sqrt(jjkt);
  u1(2)=by*sqrt(jjkt);
  u1(3)=bz*sqrt(jjkt);
  }
 }
 else
 { delta=-SMALL; // tn=1 ... transition within the same level
   if(X==1.0){jjkt=JJ*(2*JJ*JJ+3*JJ+1)/3/K_BT/(2*JJ+1);}
   else {if(X&gt;1e50)
         {jjkt=-JJ*JJ*K_BT;}
         else 
         {jjkt=(1-2*JJ-2*JJ*JJ)/XJ;
         jjkt+=JJ*JJ/X/XJ;
	 jjkt+=(JJ*JJ+2*JJ+1)*X/XJ;
	 jjkt-=(JJ+1)*(JJ+1)*XJ;
	 jjkt+=(2*JJ*JJ+2*JJ-1)*XJ*X;
	 jjkt-=JJ*JJ*XJ*X*X;
	 jjkt*=X/(1-X)/(1-X);
	 jjkt/=(1/XJ-X*XJ)*K_BT;
         jjkt/=(1/XJ-X*XJ);
         corr=JJ*(XJ*X*X-1/XJ)+(JJ+1)*X*(1/XJ-XJ);
         corr/=(1-X)*(1/XJ-X*XJ);
         jjkt-=corr*corr;
         jjkt/=K_BT;
         }
        }
 // now lets calculate mat
 u1(1)=gjmbH(1)*sqrt(jjkt)/gmh;
 u1(2)=gjmbH(2)*sqrt(jjkt)/gmh;
 u1(3)=gjmbH(3)*sqrt(jjkt)/gmh;
 }
if (pr==1) printf ("delta=%4.6g meV\n",delta);

// brillouin function has 2 effective transitions
return 2;
}
//
</PRE><SPAN CLASS="FOOTNOTESIZE"></SPAN>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node139.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node137.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1052"
  HREF="node7.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1054"
  HREF="node164.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node139.html">DyNiBC - single ion</A>
<B> Up:</B> <A
 HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A
 HREF="node137.html">Module kramer - a</A>
 &nbsp; <B>  <A ID="tex2html1053"
  HREF="node7.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1055"
  HREF="node164.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
