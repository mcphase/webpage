<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>Module kramer - a Kramers Ground State Doublet Single Ion Module</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="node154.html">
<LINK REL="previous" HREF="node152.html">
<LINK REL="next" HREF="node154.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node154.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node152.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1170"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1172"
  HREF="node180.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node154.html">Module brillouin - an</A>
<B> Up:</B> <A
 HREF="manual.html">USERS MANUAL Workshops available</A>
<B> Previous:</B> <A
 HREF="node152.html">Programs of General Interest</A>
 &nbsp; <B>  <A ID="tex2html1171"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1173"
  HREF="node180.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION000240000000000000000"></A><A ID="kramers"></A>
<BR>
Module <I CLASS="slanted">kramer</I>  - a Kramers Ground State Doublet Single Ion Module
</H1><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">The crystal field ground state of a magnetic ion often can be
approximated by a doublet. In this description the crystal field
anisotropy enters by defining the saturation moment of this doublet
in <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.23ex; vertical-align: -0.12ex; " SRC="img13.svg"
 ALT="$a$"></SPAN>,<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.12ex; " SRC="img2.svg"
 ALT="$b$"></SPAN> and <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.23ex; vertical-align: -0.12ex; " SRC="img5.svg"
 ALT="$c$"></SPAN> direction: denoting the two states of the doublet
by <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.55ex; vertical-align: -0.70ex; " SRC="img1331.svg"
 ALT="$\vert\pm&gt;$"></SPAN> the non vanishing matrix elements of the angular momentum
operator can be abbreviated by 
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<BR>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{eqnarray}
<\pm|{\hat \mathbf J}_a|\mp>=A & A^{\star}=A & A\mbox{... saturation moment in $a$\  direction}\nonumber\\
<\pm|{\hat \mathbf J}_b|\pm>=\pm B & B^{\star}=B & B\mbox{... saturation moment in $b$\  direction}\\
<\pm|{\hat \mathbf J}_c|\mp>=C & C^{\star}=-C & C\mbox{... saturation moment in $c$\  direction}\nonumber\\
\end{eqnarray}
 -->
<TABLE CLASS="equation" >
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 3.01ex; vertical-align: -0.70ex; " SRC="img1332.svg"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_a\vert\mp&gt;=A$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 1.83ex; vertical-align: -0.12ex; " SRC="img1333.svg"
 ALT="$\textstyle A^{\star}=A$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.12ex; " SRC="img1334.svg"
 ALT="$\displaystyle A\mbox{... saturation moment in $a$\ direction}$"></TD><TD class="rfill">&nbsp;</TD></TR>
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 3.01ex; vertical-align: -0.70ex; " SRC="img1335.svg"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_b\vert\pm&gt;=\pm B$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 1.83ex; vertical-align: -0.12ex; " SRC="img1336.svg"
 ALT="$\textstyle B^{\star}=B$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.12ex; " SRC="img1337.svg"
 ALT="$\displaystyle B\mbox{... saturation moment in $b$\ direction}$"></TD><TD class="rfill">(<SPAN CLASS="arabic">173</SPAN>)</TD></TR>
<TR><TD class="lfill"></TD><TD style="text-align:RIGHT"><IMG
 STYLE="height: 3.01ex; vertical-align: -0.70ex; " SRC="img1338.svg"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_c\vert\mp&gt;=C$"></TD>
<TD style="text-align:center"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.31ex; " SRC="img1339.svg"
 ALT="$\textstyle C^{\star}=-C$"></TD>
<TD style="text-align:left;"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.12ex; " SRC="img1340.svg"
 ALT="$\displaystyle C\mbox{... saturation moment in $c$\ direction}$"></TD><TD class="rfill">&nbsp;</TD></TR>
</TABLE></DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">then the single ion Hamiltonian <!-- MATH
 $H=H_{cf}- g_J \mu_b {\mathbf H}{\mathbf J}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.48ex; vertical-align: -0.78ex; " SRC="img1341.svg"
 ALT="$H=H_{cf}- g_J \mu_b {\mathbf H}{\mathbf J}$"></SPAN>
can be written as
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
\hat H=g_J \mu_B
\left (
\begin{array}{cc}
B H_b & -A H_a- C H_c\\
-A H_a +C H_c &  -B H_b
\end{array}
\right)=
\left (
\begin{array}{cc}
\alpha & \beta\\
\beta^{\star} & -\alpha
\end{array}
\right)
\end{equation}
 -->
 &nbsp;  <A ID="hamkramer"></A><IMG
 STYLE="height: 5.79ex; vertical-align: -2.32ex; " SRC="img1342.svg"
 ALT="$\displaystyle
\hat H=g_J \mu_B
\left (
\begin{array}{cc}
B H_b &amp; -A H_a- ...
...{array}{cc}
\alpha &amp; \beta\\
\beta^{\star} &amp; -\alpha
\end{array}
\right)
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">174</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">This Hamilton may be diagonalised yielding the 2 eigenvalues
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.38ex; vertical-align: -0.66ex; " SRC="img1343.svg"
 ALT="$\lambda_{\pm}$"></SPAN>,<!-- MATH
 $\Delta=\lambda_+ - \lambda_-$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.38ex; vertical-align: -0.66ex; " SRC="img1344.svg"
 ALT="$\Delta=\lambda_+ - \lambda_-$"></SPAN>:
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
\lambda_{\pm}=\pm \sqrt{\alpha^2+\beta^{\star}\beta}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 3.10ex; vertical-align: -0.66ex; " SRC="img1345.svg"
 ALT="$\displaystyle \lambda_{\pm}=\pm \sqrt{\alpha^2+\beta^{\star}\beta}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">175</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">and the eigenvectors
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
|\lambda_{\pm}>=\frac{-\beta|+>+(\alpha-\lambda_{\pm})|->}
{\sqrt{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.15ex; vertical-align: -2.74ex; " SRC="img1346.svg"
 ALT="$\displaystyle \vert\lambda_{\pm}&gt;=\frac{-\beta\vert+&gt;+(\alpha-\lambda_{\pm})\vert-&gt;}
{\sqrt{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">176</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">using Boltzmann statistics (<!-- MATH
 $Z=\exp(-\Delta/2kT)+\exp(\Delta/2kT)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.55ex; vertical-align: -0.70ex; " SRC="img1347.svg"
 ALT="$Z=\exp(-\Delta/2kT)+\exp(\Delta/2kT)$"></SPAN>) the expectation values of the magnetic
moment can be calculated as
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<{\hat \mathbf M}>=\sum_{\pm}<\lambda_{\pm}|g_J{\hat \mathbf J}|\lambda_{\pm}>
\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.62ex; vertical-align: -3.21ex; " SRC="img1348.svg"
 ALT="$\displaystyle &lt;{\hat \mathbf M}&gt;=\sum_{\pm}&lt;\lambda_{\pm}\vert g_J{\hat \mathbf J}\vert\lambda_{\pm}&gt;
\frac{\exp(-\lambda_{\pm}/kT)}{Z}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">177</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">with 
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_a|\lambda_{\pm}>=
\frac{-2A \Re[\beta^{\star}(\alpha-\lambda_{\pm})]}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 5.70ex; vertical-align: -2.29ex; " SRC="img1349.svg"
 ALT="$\displaystyle &lt;\lambda_{\pm}\vert\hat J_a\vert\lambda_{\pm}&gt;=
\frac{-2A \Re[\b...
...alpha-\lambda_{\pm})]}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">178</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_b|\lambda_{\pm}>=
\frac{-B \beta^{\star}\beta+B|\alpha-\lambda_{\pm}|^2}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 5.85ex; vertical-align: -2.29ex; " SRC="img1350.svg"
 ALT="$\displaystyle &lt;\lambda_{\pm}\vert\hat J_b\vert\lambda_{\pm}&gt;=
\frac{-B \beta^{...
...-\lambda_{\pm}\vert^2}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">179</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_c|\lambda_{\pm}>=
\frac{2 \Re(\beta C)(\alpha-\lambda_{\pm})}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 5.70ex; vertical-align: -2.29ex; " SRC="img1351.svg"
 ALT="$\displaystyle &lt;\lambda_{\pm}\vert\hat J_c\vert\lambda_{\pm}&gt;=
\frac{2 \Re(\bet...
...\alpha-\lambda_{\pm})}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">180</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">The magnetic energy <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.81ex; vertical-align: -0.12ex; " SRC="img1352.svg"
 ALT="$U$"></SPAN> can be calculated
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
U=\sum_{\pm}\lambda_{\pm}\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.62ex; vertical-align: -3.21ex; " SRC="img1353.svg"
 ALT="$\displaystyle U=\sum_{\pm}\lambda_{\pm}\frac{\exp(-\lambda_{\pm}/kT)}{Z}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">181</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">For the calculation of the magnetic excitations the program <SPAN style="font-family:monospace">mcdisp</SPAN>
needs also a function which calculates the transition matrix elements
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
M_{\alpha\beta}=<\lambda_-|\hat J_{\alpha}|\lambda_+>
<\lambda_+|\hat J_{\beta}|\lambda_-> \tanh(\Delta/2kT)
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 3.09ex; vertical-align: -0.78ex; " SRC="img1354.svg"
 ALT="$\displaystyle M_{\alpha\beta}=&lt;\lambda_-\vert\hat J_{\alpha}\vert\lambda_+&gt;
&lt;\lambda_+\vert\hat J_{\beta}\vert\lambda_-&gt; \tanh(\Delta/2kT)
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">182</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">using the expressions
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_a|\lambda_+>=
\frac{-2A (\alpha\Re(\beta)+i\lambda_+ \Im(\beta))}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.15ex; vertical-align: -2.74ex; " SRC="img1355.svg"
 ALT="$\displaystyle &lt;\lambda_-\vert\hat J_a\vert\lambda_+&gt;=
\frac{-2A (\alpha\Re(\be...
...^2+\beta^{\star}\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">183</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_b|\lambda_+>=
\frac{-2B \beta^{\star} \beta}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.02ex; vertical-align: -2.74ex; " SRC="img1356.svg"
 ALT="$\displaystyle &lt;\lambda_-\vert\hat J_b\vert\lambda_+&gt;=
\frac{-2B \beta^{\star} ...
...^2+\beta^{\star}\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">184</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"></SPAN>
<DIV CLASS="displaymath">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_c|\lambda_+>=
\frac{2|C| (-\alpha\Im(\beta)+i\lambda_+ \Re(\beta))}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
 &nbsp;  <IMG
 STYLE="height: 6.15ex; vertical-align: -2.74ex; " SRC="img1357.svg"
 ALT="$\displaystyle &lt;\lambda_-\vert\hat J_c\vert\lambda_+&gt;=
\frac{2\vert C\vert (-\a...
...^2+\beta^{\star}\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
$"> <SPAN class="FLOATRIGHT">
(<SPAN CLASS="arabic">185</SPAN>)</SPAN>
</DIV><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL">The module given in <I CLASS="slanted">/examples/cecu2a/kramer.c</I> can be compiled
by typing make in the directory <I CLASS="slanted">/examples/cecu2a/</I> thus using the
<I CLASS="slanted">/examples/cecu2a/makefile</I>. It diagonalises
the Hamiltonian (<A HREF="node155.html#ham">206</A>) and calculates the thermal expectation 
value <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.83ex; vertical-align: -0.46ex; " SRC="img1358.svg"
 ALT="$&lt;&gt;_T$"></SPAN> of the vector <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.82ex; vertical-align: -0.12ex; " SRC="img1359.svg"
 ALT="$\mathbf J$"></SPAN>. The moment <!-- MATH
 ${\mathbf M}=g_J \mu_B <{\mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.57ex; " SRC="img1360.svg"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\mathbf J}&gt;_T$"></SPAN>
is returned to the mcphas<A ID="6406"></A> program:
</SPAN>
<P>
<SPAN CLASS="SMALL">//<SPAN CLASS="FOOTNOTESIZE"></SPAN></SPAN><PRE>
// example c file for dynamically loadable module of program
// mcphas ... it must not be c++, but pure c compiled with gcc and linked 
// with ld  !! The calculation has been compared to the internal (doublet)
// routine of mcphas
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;vector.h&gt;


// this is called directly after loading it into memory from dlopen
#ifdef __linux__
//extern "C" void _init(void)
#else
//extern "C" __declspec(dllexport)void _init(void)
#endif
//{  fprintf(stdout,"kramer.so: is loaded\n");}

// called just before removing from memory
#ifdef __linux__
//extern "C" void _fini(void)
#else
//extern "C" __declspec(dllexport) void _fini(void)
#endif
//{  fprintf(stdout,"kramer.so: is removed\n");}

//routine Icalc for kramers doublet
#ifdef __MINGW32__
extern "C" __declspec(dllexport) void Icalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#else
extern "C" void Icalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#endif
{ /*on input
    T		temperature[K]
    gJmbHin	vector of effective field [meV]
    gJ          Lande factor
    MODPAR         single ion parameter values (A, B, C corresponding to &lt;+|Ja|-&gt;,&lt;-|Jb|-&gt;,&lt;+|Jc|-&gt;/i
                 MODPAR4= angle of rotation around c axis (deg)
                 MODPAR5= angle of rotation around new x axis (degree)

  on output    
    J		single ion momentum vector &lt;J&gt;
    Z		single ion partition function
    U		single ion magnetic energy
*/
// check dimensions of vector
if(Jr.Hi()!=3||Hxc.Hi()!=3||MODPAR.Hi()!=5)
   {fprintf(stderr,"Error loadable module kramer.so: wrong number of dimensions - check number of columns in file mcphas.j or number of parameters in single ion property file\n");
    exit(EXIT_FAILURE);}
Vector gjmbHin(1,Hxc.Hi());
gjmbHin=Hxc+(*g_J)*MU_B*Hext(1,3);

// rotate effective field
double sf=sin(MODPAR(4)*PI/180);
double cf=cos(MODPAR(4)*PI/180);
double st=sin(-MODPAR(5)*PI/180);
double ct=cos(-MODPAR(5)*PI/180);
Vector J(1,3);
Vector gjmbH(1,3);
Matrix rot(1,3,1,3);
      rot(1,1)=cf;    rot(1,2)=sf;   rot(1,3)=0;
      rot(2,1)=-ct*sf;rot(2,2)=ct*cf;rot(2,3)=-st;
      rot(3,1)=-st*sf;rot(3,2)=st*cf;rot(3,3)=ct;
Matrix brot(1,3,1,3);
      brot(1,1)=cf;    brot(1,2)=-sf*ct;   brot(1,3)=-st*sf;
      brot(2,1)=sf;brot(2,2)=ct*cf;brot(2,3)=st*cf;
      brot(3,1)=0.0  ;brot(3,2)=-st;brot(3,3)=ct;

//printf("%g %g %g\n",gjmbHin(1),gjmbHin(2),gjmbHin(3));
gjmbH=rot*gjmbHin;
//printf("%g %g %g\n",gjmbH(1),gjmbH(2),gjmbH(3));
   
  double alpha, betar, betai, lambdap,lambdap_KBT, lambdap2, expp, expm, np, nm;
  double nennerp, nennerm, jap, jam, jbp, jbm, jcp, jcm,Z;
  double alpha_lambdap,alphaplambdap,alphaxlambdap;
  alpha = MODPAR[2] * gjmbH[2];
  betar = -MODPAR[1] * gjmbH[1];
  betai = -MODPAR[3] * gjmbH[3];

  lambdap2 = alpha * alpha + betar * betar + betai * betai;
  lambdap = sqrt (lambdap2);
  lambdap_KBT=lambdap/KB/(*T);
  if (lambdap_KBT&gt;700){lambdap_KBT=700;}
  if (lambdap_KBT&lt;-700){lambdap_KBT=-700;}
  expm = exp (lambdap_KBT);
  expp = 1/expm; //=exp (-lambdap_KBT);
  Z = expp + expm;
  (*lnZ)=log(Z);
  np = expp / Z;
  nm = expm / Z;
  (*U)=lambdap*(np-nm); // energy
//printf("T=%g expp=%g expm=%g \n",(*T),expp,expm);

    alphaxlambdap=alpha*lambdap;
    alpha_lambdap=alpha-lambdap;
    alphaplambdap=alpha+lambdap;
    nennerp=  2.0*(-alphaxlambdap+lambdap2);    
    nennerm=  2.0*(alphaxlambdap+lambdap2);    

  if (nennerp &gt; SMALL)
    {
      jap = -MODPAR[1] * 2.0 * betar * (alpha_lambdap) / nennerp;
      jbp = MODPAR[2] * (2.0 * alpha*alpha_lambdap) / nennerp;
      jcp = -2.0 * MODPAR[3] * betai * (alpha_lambdap) / nennerp;
    }
  else
    {
      jap = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbp = -copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbp = 0;
	}
      jcp = 0;
    }

  if (nennerm &gt; SMALL)
    {
      jam = -MODPAR[1] * 2.0 * betar * (alphaplambdap) / nennerm;
      jbm = MODPAR[2] * (2.0 * alpha*alphaplambdap) / nennerm;
      jcm = -2.0 * MODPAR[3] * betai * (alphaplambdap) / nennerm;
    }
  else
    {
      jam = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbm = copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbm = 0;
	}
      jcm = 0;
    }

  J[1] = np * jap + nm * jam;
  J[2] = np * jbp + nm * jbm;
  J[3] = np * jcp + nm * jcm;
// printf ("np=%g nm=%g jap=%g jbp=%g jcp=%g jam=%g jbm=%g jcm=%g \n",np,nm,jap,jbp,jcp,jam,jbm,jcm);
//  printf ("gjmbHa=%g gjmbHb=%g gjmbHc=%g Ja=%g Jb=%g Jc=%g \n", gjmbH[1], gjmbH[2], gjmbH[3], J[1], J[2], J[3]);
//printf("J %g %g %g\n",J(1),J(2),J(3));

Jr=brot*J;
//printf("J %g %g %g\n",Jr(1),Jr(2),Jr(3));


return;
}

#ifdef __MINGW32__
extern "C" __declspec(dllexport) void mcalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      ComplexMatrix &amp; est)
#else
extern "C" void mcalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      ComplexMatrix &amp; est)
#endif
{ double U,lnz;
  Icalc(Jr,T, Hxc,Hext,g_J,MODPAR,sipffile,&amp;U,&amp;lnz,est); 
  Jr*=(*g_J);
}
/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32__
extern "C" __declspec(dllexport) int du1calc(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; u1r,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#else
extern "C" int du1calc(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; u1r,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#endif
{ 
  /*on input
    tn          transition-number - meaningless for kramers doublet, because there is only one transition
    MODPAR         A,M,Ci...saturation moment/gJ[MU_B] of groundstate doublet in a.b.c direction
    g_J		lande factor
    T		temperature[K]
    gjmbH	vector of effective field [meV]
  on output    
    delta	splitting of kramers doublet [meV]
    u1r(i)	&lt;-|Ji-&lt;Ji&gt;|+&gt; sqrt(tanh(delta/2kT))
*/
  double alpha, betar, betai, lambdap,lambdap_KBT, lambdap2, expp, expm, np, nm;
  double nennerp, nennerm, nenner;
  complex&lt;double&gt; ja,jb,jc,i(0,1),jap,jbp,jcp,jam,jbm,jcm;
  double alpha_lambdap,alphaplambdap,alphaxlambdap;
  double Z,lnz,u;
  static int pr;
  static Vector gjmbHin(1,3);
gjmbHin=Hxc+(*g_J)*MU_B*Hext(1,3);
  static Vector Jin(1,3);
  static Vector J(1,3);
  static ComplexVector u1(1,3);
  // clalculate thermal expectation values (needed for quasielastic scattering)
  Jin=0;if(T&gt;0){ Icalc(Jin,&amp;T,Hxc,Hext,g_J,MODPAR,sipffile,&amp;lnz,&amp;u,est);}
                else {T=-T;}
// rotate effective field
double sf=sin(MODPAR(4)*PI/180);
double cf=cos(MODPAR(4)*PI/180);
double st=sin(-MODPAR(5)*PI/180);
double ct=cos(-MODPAR(5)*PI/180);
Vector gjmbH(1,3);
Matrix rot(1,3,1,3);
      rot(1,1)=cf;    rot(1,2)=sf;   rot(1,3)=0;
      rot(2,1)=-ct*sf;rot(2,2)=ct*cf;rot(2,3)=-st;
      rot(3,1)=-st*sf;rot(3,2)=st*cf;rot(3,3)=ct;
Matrix brot(1,3,1,3);
      brot(1,1)=cf;    brot(1,2)=-sf*ct;   brot(1,3)=-st*sf;
      brot(2,1)=sf;brot(2,2)=ct*cf;brot(2,3)=st*cf;
      brot(3,1)=0.0  ;brot(3,2)=-st;brot(3,3)=ct;

gjmbH=rot*gjmbHin;
J=rot*Jin;

  pr=0;
  if (tn&lt;0) {pr=1;tn*=-1;}

  alpha = MODPAR[2] * gjmbH[2];
  betar = -MODPAR[1] * gjmbH[1];
  betai = -MODPAR[3] * gjmbH[3];
  lambdap2 = alpha * alpha + betar * betar + betai * betai;
  lambdap = sqrt (lambdap2);
  
  lambdap_KBT=lambdap/KB/T;
  if (lambdap_KBT&gt;700){lambdap_KBT=700;}
  if (lambdap_KBT&lt;-700){lambdap_KBT=-700;}
  expm = exp (lambdap_KBT);
  expp = 1/expm; //=exp (-lambdap_KBT);
  Z = expp + expm;
  np = expp / Z;
  nm = expm / Z;

    alphaxlambdap=alpha*lambdap;
    alpha_lambdap=alpha-lambdap;
    alphaplambdap=alpha+lambdap;
    nennerp=  2.0*(-alphaxlambdap+lambdap2);    
    nennerm=  2.0*(alphaxlambdap+lambdap2);    

if (tn==2)
 {delta=2*lambdap; //set delta !!!
    nenner=sqrt(nennerp*nennerm);

  if (nenner &gt; SMALL)
    {
      ja = -MODPAR[1] * 2.0*(alpha * betar+i * betai * lambdap) / nenner;
      jb = -MODPAR[2] * 2.0 * (betar*betar+betai*betai) / nenner;
      jc = -MODPAR[3] * 2.0*(alpha*betai -i *betar*lambdap) / nenner;
    }
  else
    {
      if (alpha &gt; SMALL)
	{ja = MODPAR[1];  // &lt;-| is the ground state
  	 jb = 0;
         jc = -i*MODPAR[3];
	}
      else
	{ja = MODPAR[1];  // &lt;+| is the ground state
  	 jb = 0;
         jc = i*MODPAR[3]; 	
	}
    }

 if (delta&gt;SMALL)
  {// now lets calculate mat
  u1(1)=ja*sqrt(nm-np);
  u1(2)=jb*sqrt(nm-np);
  u1(3)=jc*sqrt(nm-np);
  } else
  {// quasielastic scattering needs epsilon * nm / KT ....
  u1(1)=ja*sqrt(nm/KB/T);
  u1(2)=jb*sqrt(nm/KB/T);
  u1(3)=jc*sqrt(nm/KB/T);
  }
 }
 else
 { delta=-SMALL; // transition within the same level
  if (nennerp &gt; SMALL)
    {
      jap = -MODPAR[1] * 2.0 * betar * (alpha_lambdap) / nennerp;
      jbp = MODPAR[2] * (2.0 * alpha*alpha_lambdap) / nennerp;
      jcp = -2.0 * MODPAR[3] * betai * (alpha_lambdap) / nennerp;
    }
  else
    {
      jap = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbp = -copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbp = -MODPAR[2];
	}
      jcp = 0;
    }

  if (nennerm &gt; SMALL)
    {
      jam = -MODPAR[1] * 2.0 * betar * (alphaplambdap) / nennerm;
      jbm = MODPAR[2] * (2.0 * alpha*alphaplambdap) / nennerm;
      jcm = -2.0 * MODPAR[3] * betai * (alphaplambdap) / nennerm;
    }
  else
    {
      jam = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbm = copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbm = MODPAR[2];
	}
      jcm = 0;
    }
 if (tn==1)
 {// now lets calculate mat
 u1(1)=(jam-J(1))*sqrt(nm/KB/T);
 u1(2)=(jbm-J(2))*sqrt(nm/KB/T);
 u1(3)=(jcm-J(3))*sqrt(nm/KB/T);
 }else{ // tn = 3 in this case
 // now lets calculate mat
 u1(1)=(jap-J(1))*sqrt(np/KB/T);
 u1(2)=(jbp-J(2))*sqrt(np/KB/T);
 u1(3)=(jcp-J(3))*sqrt(np/KB/T);
 }
}
if (pr==1) printf ("delta=%4.6g meV\n",delta);
 
// rotate back mat(i,j)
for(int i=1;i&lt;=3;++i)for(int j=1;j&lt;=3;++j){
u1r(i)=0.0;
for(int i1=1;i1&lt;=3;++i1){
u1r(i)+=brot(i,i1)*u1(i1);
}}


return 3;// kramers doublet has always exactly one transition + 2 levels (quasielastic scattering)!
}

/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32__
extern "C" __declspec(dllexport) int dm1(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; m1,float &amp; maxE,ComplexMatrix &amp; est)
#else
extern "C" int dm1(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; m1,float &amp; maxE,ComplexMatrix &amp; est)
#endif
{int nnt,n,nd;
nnt=du1calc(tn,T,Hxc,Hext,g_J,MODPAR,sipffile,m1,maxE,n,nd,est);m1*=(*g_J);return nnt; 
}
//
</PRE><SPAN CLASS="SMALL"><SPAN CLASS="FOOTNOTESIZE"></SPAN>

</SPAN>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node154.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node152.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1170"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1172"
  HREF="node180.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node154.html">Module brillouin - an</A>
<B> Up:</B> <A
 HREF="manual.html">USERS MANUAL Workshops available</A>
<B> Previous:</B> <A
 HREF="node152.html">Programs of General Interest</A>
 &nbsp; <B>  <A ID="tex2html1171"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1173"
  HREF="node180.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
