<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2017.2 (Released Jan 23, 2017) -->
<HTML>
<HEAD>
<TITLE>Module kramer - a Kramers Ground State Doublet Single Ion Module</TITLE>
<META NAME="description" CONTENT="Module kramer - a Kramers Ground State Doublet Single Ion Module">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2017.2">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="node126.html">
<LINK REL="previous" HREF="node124.html">
<LINK REL="up" HREF="manual.html">
<LINK REL="next" HREF="node126.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html2170"
  HREF="node126.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2164"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2158"
  HREF="node124.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2166"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2168"
  HREF="node152.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2171"
  HREF="node126.html">Module brillouin - an</A>
<B> Up:</B> <A NAME="tex2html2165"
  HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A NAME="tex2html2159"
  HREF="node124.html">Programs of General Interest</A>
 &nbsp; <B>  <A NAME="tex2html2167"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html2169"
  HREF="node152.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION000250000000000000000"></A><A NAME="kramers"></A>
<BR>
Module <I CLASS="slanted">kramer</I>  - a Kramers Ground State Doublet Single Ion Module
</H1>

<P>
The crystal field ground state of a magnetic ion often can be
approximated by a doublet. In this description the crystal field
anisotropy enters by defining the saturation moment of this doublet
in <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$a$"></SPAN>,<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$b$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$c$"></SPAN> direction: denoting the two states of the doublet
by <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img1032.png"
 ALT="$\vert\pm&gt;$"></SPAN> the non vanishing matrix elements of the angular momentum
operator can be abbreviated by 

<P>
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
<\pm|{\hat \mathbf J}_a|\mp>=A & A^{\star}=A & A\mbox{... saturation moment in $a$\  direction}\nonumber\\
<\pm|{\hat \mathbf J}_b|\pm>=\pm B & B^{\star}=B & B\mbox{... saturation moment in $b$\  direction}\\
<\pm|{\hat \mathbf J}_c|\mp>=C & C^{\star}=-C & C\mbox{... saturation moment in $c$\  direction}\nonumber\\
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="117" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img1033.png"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_a\vert\mp&gt;=A$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="56" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img1034.png"
 ALT="$\textstyle A^{\star}=A$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="267" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1035.png"
 ALT="$\displaystyle A\mbox{... saturation moment in $a$\ direction}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="129" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img1036.png"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_b\vert\pm&gt;=\pm B$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="58" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img1037.png"
 ALT="$\textstyle B^{\star}=B$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="266" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1038.png"
 ALT="$\displaystyle B\mbox{... saturation moment in $b$\ direction}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">136</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT"><IMG
 WIDTH="116" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img1039.png"
 ALT="$\displaystyle &lt;\pm\vert{\hat \mathbf J}_c\vert\mp&gt;=C$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="70" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img1040.png"
 ALT="$\textstyle C^{\star}=-C$"></TD>
<TD ALIGN="LEFT" WIDTH="50%" NOWRAP><IMG
 WIDTH="266" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1041.png"
 ALT="$\displaystyle C\mbox{... saturation moment in $c$\ direction}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
then the single ion Hamiltonian <!-- MATH
 $H=H_{cf}- g_J \mu_b {\mathbf H}{\mathbf J}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="142" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1042.png"
 ALT="$H=H_{cf}- g_J \mu_b {\mathbf H}{\mathbf J}$"></SPAN>
can be written as

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\hat H=g_J \mu_B
\left (
\begin{array}{cc}
B H_b & -A H_a- C H_c\\
-A H_a +C H_c &  -B H_b
\end{array}
\right)=
\left (
\begin{array}{cc}
\alpha & \beta\\
\beta^{\star} & -\alpha
\end{array}
\right)
\end{equation}
 -->
<A NAME="hamkramer"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="hamkramer"></A><IMG
 WIDTH="438" HEIGHT="66" BORDER="0"
 SRC="img1043.png"
 ALT="\begin{displaymath}
\hat H=g_J \mu_B
\left (
\begin{array}{cc}
B H_b &amp; -A ...
...pha &amp; \beta\\
\beta^{\star} &amp; -\alpha
\end{array}
\right)
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">137</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
This Hamilton may be diagonalised yielding the 2 eigenvalues
<SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1044.png"
 ALT="$\lambda_{\pm}$"></SPAN>,<!-- MATH
 $\Delta=\lambda_+ - \lambda_-$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="98" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1045.png"
 ALT="$\Delta=\lambda_+ - \lambda_-$"></SPAN>:

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\lambda_{\pm}=\pm \sqrt{\alpha^2+\beta^{\star}\beta}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="134" HEIGHT="28" BORDER="0"
 SRC="img1046.png"
 ALT="\begin{displaymath}
\lambda_{\pm}=\pm \sqrt{\alpha^2+\beta^{\star}\beta}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">138</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
and the eigenvectors

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
|\lambda_{\pm}>=\frac{-\beta|+>+(\alpha-\lambda_{\pm})|->}
{\sqrt{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="226" HEIGHT="47" BORDER="0"
 SRC="img1047.png"
 ALT="\begin{displaymath}
\vert\lambda_{\pm}&gt;=\frac{-\beta\vert+&gt;+(\alpha-\lambda_{\p...
...
{\sqrt{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">139</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
using Boltzmann statistics (<!-- MATH
 $Z=\exp(-\Delta/2kT)+\exp(\Delta/2kT)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="241" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img1048.png"
 ALT="$Z=\exp(-\Delta/2kT)+\exp(\Delta/2kT)$"></SPAN>) the expectation values of the magnetic
moment can be calculated as

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<{\hat \mathbf M}>=\sum_{\pm}<\lambda_{\pm}|g_J{\hat \mathbf J}|\lambda_{\pm}>
\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="307" HEIGHT="51" BORDER="0"
 SRC="img1049.png"
 ALT="\begin{displaymath}
&lt;{\hat \mathbf M}&gt;=\sum_{\pm}&lt;\lambda_{\pm}\vert g_J{\hat \mathbf J}\vert\lambda_{\pm}&gt;
\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">140</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
with 

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_a|\lambda_{\pm}>=
\frac{-2A \Re[\beta^{\star}(\alpha-\lambda_{\pm})]}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="249" HEIGHT="44" BORDER="0"
 SRC="img1050.png"
 ALT="\begin{displaymath}
&lt;\lambda_{\pm}\vert\hat J_a\vert\lambda_{\pm}&gt;=
\frac{-2A ...
...pm})]}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">141</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_b|\lambda_{\pm}>=
\frac{-B \beta^{\star}\beta+B|\alpha-\lambda_{\pm}|^2}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="266" HEIGHT="45" BORDER="0"
 SRC="img1051.png"
 ALT="\begin{displaymath}
&lt;\lambda_{\pm}\vert\hat J_b\vert\lambda_{\pm}&gt;=
\frac{-B \...
...ert^2}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">142</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_{\pm}|\hat J_c|\lambda_{\pm}>=
\frac{2 \Re(\beta C)(\alpha-\lambda_{\pm})}
{|\alpha-\lambda_{\pm}|^2+\beta^{\star}\beta}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="232" HEIGHT="44" BORDER="0"
 SRC="img1052.png"
 ALT="\begin{displaymath}
&lt;\lambda_{\pm}\vert\hat J_c\vert\lambda_{\pm}&gt;=
\frac{2 \R...
...\pm})}
{\vert\alpha-\lambda_{\pm}\vert^2+\beta^{\star}\beta}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">143</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
The magnetic energy <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1053.png"
 ALT="$U$"></SPAN> can be calculated

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
U=\sum_{\pm}\lambda_{\pm}\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="178" HEIGHT="51" BORDER="0"
 SRC="img1054.png"
 ALT="\begin{displaymath}
U=\sum_{\pm}\lambda_{\pm}\frac{\exp(-\lambda_{\pm}/kT)}{Z}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">144</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
For the calculation of the magnetic excitations the program <TT>mcdisp</TT>
needs also a function which calculates the transition matrix elements

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
M_{\alpha\beta}=<\lambda_-|\hat J_{\alpha}|\lambda_+>
<\lambda_+|\hat J_{\beta}|\lambda_-> \tanh(\Delta/2kT)
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="346" HEIGHT="30" BORDER="0"
 SRC="img1055.png"
 ALT="\begin{displaymath}
M_{\alpha\beta}=&lt;\lambda_-\vert\hat J_{\alpha}\vert\lambda_...
...\lambda_+\vert\hat J_{\beta}\vert\lambda_-&gt; \tanh(\Delta/2kT)
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">145</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
using the expressions

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_a|\lambda_+>=
\frac{-2A (\alpha\Re(\beta)+i\lambda_+ \Im(\beta))}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="382" HEIGHT="47" BORDER="0"
 SRC="img1056.png"
 ALT="\begin{displaymath}
&lt;\lambda_-\vert\hat J_a\vert\lambda_+&gt;=
\frac{-2A (\alpha\...
...\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">146</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_b|\lambda_+>=
\frac{-2B \beta^{\star} \beta}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="381" HEIGHT="47" BORDER="0"
 SRC="img1057.png"
 ALT="\begin{displaymath}
&lt;\lambda_-\vert\hat J_b\vert\lambda_+&gt;=
\frac{-2B \beta^{\...
...\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">147</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
<\lambda_-|\hat J_c|\lambda_+>=
\frac{2|C| (-\alpha\Im(\beta)+i\lambda_+ \Re(\beta))}
{\sqrt{(|\alpha-\lambda_{+}|^2+\beta^{\star}\beta)
(|\alpha-\lambda_{-}|^2+\beta^{\star}\beta)}}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="381" HEIGHT="47" BORDER="0"
 SRC="img1058.png"
 ALT="\begin{displaymath}
&lt;\lambda_-\vert\hat J_c\vert\lambda_+&gt;=
\frac{2\vert C\ver...
...\beta)
(\vert\alpha-\lambda_{-}\vert^2+\beta^{\star}\beta)}}
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">148</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
The module given in <I CLASS="slanted">/examples/cecu2a/kramer.c</I> can be compiled
by typing make in the directory <I CLASS="slanted">/examples/cecu2a/</I> thus using the
<I CLASS="slanted">/examples/cecu2a/makefile</I>. It diagonalises
the Hamiltonian (<A HREF="node127.html#ham">166</A>) and calculates the thermal expectation 
value <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img1059.png"
 ALT="$&lt;&gt;_T$"></SPAN> of the vector <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1060.png"
 ALT="$\mathbf J$"></SPAN>. The moment <!-- MATH
 ${\mathbf M}=g_J \mu_B <{\mathbf J}>_T$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="137" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img1061.png"
 ALT="${\mathbf M}=g_J \mu_B &lt;{\mathbf J}&gt;_T$"></SPAN>
is returned to the mcphas<A NAME="12575"></A> program:

<P>
//<PRE>
// example c file for dynamically loadable module of program
// mcphas ... it must not be c++, but pure c compiled with gcc and linked 
// with ld  !! The calculation has been compared to the internal (doublet)
// routine of mcphas
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;vector.h&gt;

#define MU_B 0.05788
#define K_B  0.0862
#define SMALL 1e-10
#define PI   3.14159265

// this is called directly after loading it into memory from dlopen
#ifdef __linux__
//extern "C" void _init(void)
#else
//extern "C" __declspec(dllexport)void _init(void)
#endif
//{  fprintf(stdout,"kramer.so: is loaded\n");}

// called just before removing from memory
#ifdef __linux__
//extern "C" void _fini(void)
#else
//extern "C" __declspec(dllexport) void _fini(void)
#endif
//{  fprintf(stdout,"kramer.so: is removed\n");}

//routine Icalc for kramers doublet
#ifdef __MINGW32__
extern "C" __declspec(dllexport) void Icalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#else
extern "C" void Icalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      double * lnZ,double * U,ComplexMatrix &amp; est)
#endif
{ /*on input
    T		temperature[K]
    gJmbHin	vector of effective field [meV]
    gJ          Lande factor
    MODPAR         single ion parameter values (A, B, C corresponding to &lt;+|Ja|-&gt;,&lt;-|Jb|-&gt;,&lt;+|Jc|-&gt;/i
                 MODPAR4= angle of rotation around c axis (deg)
                 MODPAR5= angle of rotation around new x axis (degree)

  on output    
    J		single ion momentum vector &lt;J&gt;
    Z		single ion partition function
    U		single ion magnetic energy
*/
// check dimensions of vector
if(Jr.Hi()!=3||Hxc.Hi()!=3||MODPAR.Hi()!=5)
   {fprintf(stderr,"Error loadable module kramer.so: wrong number of dimensions - check number of columns in file mcphas.j or number of parameters in single ion property file\n");
    exit(EXIT_FAILURE);}
Vector gjmbHin(1,Hxc.Hi());
gjmbHin=Hxc+(*g_J)*MU_B*Hext;

// rotate effective field
double sf=sin(MODPAR(4)*PI/180);
double cf=cos(MODPAR(4)*PI/180);
double st=sin(-MODPAR(5)*PI/180);
double ct=cos(-MODPAR(5)*PI/180);
Vector J(1,3);
Vector gjmbH(1,3);
Matrix rot(1,3,1,3);
      rot(1,1)=cf;    rot(1,2)=sf;   rot(1,3)=0;
      rot(2,1)=-ct*sf;rot(2,2)=ct*cf;rot(2,3)=-st;
      rot(3,1)=-st*sf;rot(3,2)=st*cf;rot(3,3)=ct;
Matrix brot(1,3,1,3);
      brot(1,1)=cf;    brot(1,2)=-sf*ct;   brot(1,3)=-st*sf;
      brot(2,1)=sf;brot(2,2)=ct*cf;brot(2,3)=st*cf;
      brot(3,1)=0.0  ;brot(3,2)=-st;brot(3,3)=ct;

//printf("%g %g %g\n",gjmbHin(1),gjmbHin(2),gjmbHin(3));
gjmbH=rot*gjmbHin;
//printf("%g %g %g\n",gjmbH(1),gjmbH(2),gjmbH(3));
   
  double alpha, betar, betai, lambdap,lambdap_K_BT, lambdap2, expp, expm, np, nm;
  double nennerp, nennerm, jap, jam, jbp, jbm, jcp, jcm,Z;
  double alpha_lambdap,alphaplambdap,alphaxlambdap;
  alpha = MODPAR[2] * gjmbH[2];
  betar = -MODPAR[1] * gjmbH[1];
  betai = -MODPAR[3] * gjmbH[3];

  lambdap2 = alpha * alpha + betar * betar + betai * betai;
  lambdap = sqrt (lambdap2);
  lambdap_K_BT=lambdap/K_B/(*T);
  if (lambdap_K_BT&gt;700){lambdap_K_BT=700;}
  if (lambdap_K_BT&lt;-700){lambdap_K_BT=-700;}
  expm = exp (lambdap_K_BT);
  expp = 1/expm; //=exp (-lambdap_K_BT);
  Z = expp + expm;
  (*lnZ)=log(Z);
  np = expp / Z;
  nm = expm / Z;
  (*U)=lambdap*(np-nm); // energy
//printf("T=%g expp=%g expm=%g \n",(*T),expp,expm);

    alphaxlambdap=alpha*lambdap;
    alpha_lambdap=alpha-lambdap;
    alphaplambdap=alpha+lambdap;
    nennerp=  2.0*(-alphaxlambdap+lambdap2);    
    nennerm=  2.0*(alphaxlambdap+lambdap2);    

  if (nennerp &gt; SMALL)
    {
      jap = -MODPAR[1] * 2.0 * betar * (alpha_lambdap) / nennerp;
      jbp = MODPAR[2] * (2.0 * alpha*alpha_lambdap) / nennerp;
      jcp = -2.0 * MODPAR[3] * betai * (alpha_lambdap) / nennerp;
    }
  else
    {
      jap = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbp = -copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbp = 0;
	}
      jcp = 0;
    }

  if (nennerm &gt; SMALL)
    {
      jam = -MODPAR[1] * 2.0 * betar * (alphaplambdap) / nennerm;
      jbm = MODPAR[2] * (2.0 * alpha*alphaplambdap) / nennerm;
      jcm = -2.0 * MODPAR[3] * betai * (alphaplambdap) / nennerm;
    }
  else
    {
      jam = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbm = copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbm = 0;
	}
      jcm = 0;
    }

  J[1] = np * jap + nm * jam;
  J[2] = np * jbp + nm * jbm;
  J[3] = np * jcp + nm * jcm;
// printf ("np=%g nm=%g jap=%g jbp=%g jcp=%g jam=%g jbm=%g jcm=%g \n",np,nm,jap,jbp,jcp,jam,jbm,jcm);
//  printf ("gjmbHa=%g gjmbHb=%g gjmbHc=%g Ja=%g Jb=%g Jc=%g \n", gjmbH[1], gjmbH[2], gjmbH[3], J[1], J[2], J[3]);
//printf("J %g %g %g\n",J(1),J(2),J(3));

Jr=brot*J;
//printf("J %g %g %g\n",Jr(1),Jr(2),Jr(3));


return;
}

#ifdef __MINGW32__
extern "C" __declspec(dllexport) void mcalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      ComplexMatrix &amp; est)
#else
extern "C" void mcalc(Vector &amp; Jr,double * T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J, Vector &amp; MODPAR,char ** sipffile,
                      ComplexMatrix &amp; est)
#endif
{ double U,lnz;
  Icalc(Jr,T, Hxc,Hext,g_J,MODPAR,sipffile,&amp;U,&amp;lnz,est); 
  Jr*=(*g_J);
}
/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32__
extern "C" __declspec(dllexport) int du1calc(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; u1r,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#else
extern "C" int du1calc(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; u1r,float &amp; delta,int &amp; n, int &amp; nd,ComplexMatrix &amp; est)
#endif
{ 
  /*on input
    tn          transition-number - meaningless for kramers doublet, because there is only one transition
    MODPAR         A,M,Ci...saturation moment/gJ[MU_B] of groundstate doublet in a.b.c direction
    g_J		lande factor
    T		temperature[K]
    gjmbH	vector of effective field [meV]
  on output    
    delta	splitting of kramers doublet [meV]
    u1r(i)	&lt;-|Ji-&lt;Ji&gt;|+&gt; sqrt(tanh(delta/2kT))
*/
  double alpha, betar, betai, lambdap,lambdap_K_BT, lambdap2, expp, expm, np, nm;
  double nennerp, nennerm, nenner;
  complex&lt;double&gt; ja,jb,jc,i(0,1),jap,jbp,jcp,jam,jbm,jcm;
  double alpha_lambdap,alphaplambdap,alphaxlambdap;
  double Z,lnz,u;
  static int pr;
  static Vector gjmbHin(1,3);
gjmbHin=Hxc+(*g_J)*MU_B*Hext;
  static Vector Jin(1,3);
  static Vector J(1,3);
  static ComplexVector u1(1,3);
  // clalculate thermal expectation values (needed for quasielastic scattering)
  Jin=0;if(T&gt;0){ Icalc(Jin,&amp;T,Hxc,Hext,g_J,MODPAR,sipffile,&amp;lnz,&amp;u,est);}
                else {T=-T;}
// rotate effective field
double sf=sin(MODPAR(4)*PI/180);
double cf=cos(MODPAR(4)*PI/180);
double st=sin(-MODPAR(5)*PI/180);
double ct=cos(-MODPAR(5)*PI/180);
Vector gjmbH(1,3);
Matrix rot(1,3,1,3);
      rot(1,1)=cf;    rot(1,2)=sf;   rot(1,3)=0;
      rot(2,1)=-ct*sf;rot(2,2)=ct*cf;rot(2,3)=-st;
      rot(3,1)=-st*sf;rot(3,2)=st*cf;rot(3,3)=ct;
Matrix brot(1,3,1,3);
      brot(1,1)=cf;    brot(1,2)=-sf*ct;   brot(1,3)=-st*sf;
      brot(2,1)=sf;brot(2,2)=ct*cf;brot(2,3)=st*cf;
      brot(3,1)=0.0  ;brot(3,2)=-st;brot(3,3)=ct;

gjmbH=rot*gjmbHin;
J=rot*Jin;

  pr=0;
  if (tn&lt;0) {pr=1;tn*=-1;}

  alpha = MODPAR[2] * gjmbH[2];
  betar = -MODPAR[1] * gjmbH[1];
  betai = -MODPAR[3] * gjmbH[3];
  lambdap2 = alpha * alpha + betar * betar + betai * betai;
  lambdap = sqrt (lambdap2);
  
  lambdap_K_BT=lambdap/K_B/T;
  if (lambdap_K_BT&gt;700){lambdap_K_BT=700;}
  if (lambdap_K_BT&lt;-700){lambdap_K_BT=-700;}
  expm = exp (lambdap_K_BT);
  expp = 1/expm; //=exp (-lambdap_K_BT);
  Z = expp + expm;
  np = expp / Z;
  nm = expm / Z;

    alphaxlambdap=alpha*lambdap;
    alpha_lambdap=alpha-lambdap;
    alphaplambdap=alpha+lambdap;
    nennerp=  2.0*(-alphaxlambdap+lambdap2);    
    nennerm=  2.0*(alphaxlambdap+lambdap2);    

if (tn==2)
 {delta=2*lambdap; //set delta !!!
    nenner=sqrt(nennerp*nennerm);

  if (nenner &gt; SMALL)
    {
      ja = -MODPAR[1] * 2.0*(alpha * betar+i * betai * lambdap) / nenner;
      jb = -MODPAR[2] * 2.0 * (betar*betar+betai*betai) / nenner;
      jc = -MODPAR[3] * 2.0*(alpha*betai -i *betar*lambdap) / nenner;
    }
  else
    {
      if (alpha &gt; SMALL)
	{ja = MODPAR[1];  // &lt;-| is the ground state
  	 jb = 0;
         jc = -i*MODPAR[3];
	}
      else
	{ja = MODPAR[1];  // &lt;+| is the ground state
  	 jb = 0;
         jc = i*MODPAR[3]; 	
	}
    }

 if (delta&gt;SMALL)
  {// now lets calculate mat
  u1(1)=ja*sqrt(nm-np);
  u1(2)=jb*sqrt(nm-np);
  u1(3)=jc*sqrt(nm-np);
  } else
  {// quasielastic scattering needs epsilon * nm / KT ....
  u1(1)=ja*sqrt(nm/K_B/T);
  u1(2)=jb*sqrt(nm/K_B/T);
  u1(3)=jc*sqrt(nm/K_B/T);
  }
 }
 else
 { delta=-SMALL; // transition within the same level
  if (nennerp &gt; SMALL)
    {
      jap = -MODPAR[1] * 2.0 * betar * (alpha_lambdap) / nennerp;
      jbp = MODPAR[2] * (2.0 * alpha*alpha_lambdap) / nennerp;
      jcp = -2.0 * MODPAR[3] * betai * (alpha_lambdap) / nennerp;
    }
  else
    {
      jap = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbp = -copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbp = -MODPAR[2];
	}
      jcp = 0;
    }

  if (nennerm &gt; SMALL)
    {
      jam = -MODPAR[1] * 2.0 * betar * (alphaplambdap) / nennerm;
      jbm = MODPAR[2] * (2.0 * alpha*alphaplambdap) / nennerm;
      jcm = -2.0 * MODPAR[3] * betai * (alphaplambdap) / nennerm;
    }
  else
    {
      jam = 0;
      if (alpha * alpha &gt; SMALL)
	{
	  jbm = copysign (MODPAR[2], alpha);
	}
      else
	{
	  jbm = MODPAR[2];
	}
      jcm = 0;
    }
 if (tn==1)
 {// now lets calculate mat
 u1(1)=(jam-J(1))*sqrt(nm/K_B/T);
 u1(2)=(jbm-J(2))*sqrt(nm/K_B/T);
 u1(3)=(jcm-J(3))*sqrt(nm/K_B/T);
 }else{ // tn = 3 in this case
 // now lets calculate mat
 u1(1)=(jap-J(1))*sqrt(np/K_B/T);
 u1(2)=(jbp-J(2))*sqrt(np/K_B/T);
 u1(3)=(jcp-J(3))*sqrt(np/K_B/T);
 }
}
if (pr==1) printf ("delta=%4.6g meV\n",delta);
 
// rotate back mat(i,j)
for(int i=1;i&lt;=3;++i)for(int j=1;j&lt;=3;++j){
u1r(i)=0.0;
for(int i1=1;i1&lt;=3;++i1){
u1r(i)+=brot(i,i1)*u1(i1);
}}


return 3;// kramers doublet has always exactly one transition + 2 levels (quasielastic scattering)!
}

/**************************************************************************/
// for mcdisp this routine is needed
#ifdef __MINGW32__
extern "C" __declspec(dllexport) int dm1(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; m1,float &amp; maxE,ComplexMatrix &amp; est)
#else
extern "C" int dm1(int &amp; tn,double &amp; T, Vector &amp; Hxc,Vector &amp; Hext,double * g_J,Vector &amp; MODPAR, char ** sipffile,
                       ComplexVector &amp; m1,float &amp; maxE,ComplexMatrix &amp; est)
#endif
{int nnt,n,nd;
nnt=du1calc(tn,T,Hxc,Hext,g_J,MODPAR,sipffile,m1,maxE,n,nd,est);m1*=(*g_J);return nnt; 
}
//
</PRE>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html2170"
  HREF="node126.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2164"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2158"
  HREF="node124.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2166"
  HREF="node8.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2168"
  HREF="node152.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html2171"
  HREF="node126.html">Module brillouin - an</A>
<B> Up:</B> <A NAME="tex2html2165"
  HREF="manual.html">McPhase USERS MANUAL</A>
<B> Previous:</B> <A NAME="tex2html2159"
  HREF="node124.html">Programs of General Interest</A>
 &nbsp; <B>  <A NAME="tex2html2167"
  HREF="node8.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html2169"
  HREF="node152.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
